append@append(QHL) -> QH@ QHL = [ QH =  query_handle()    
append@append(QH1, QH2) -> QH3@ QH1 = QH2 =  QH3 =  query_handle()    
cursor@cursor(QH) -> Cursor@ QH =  Cursor =  query_cursor()    
cursor@cursor(QH, Options) -> Cursor@ QH =  Options = [Option] | Option Option = {cache_all,  Cursor =  query_cursor()    
delete_cursor@delete_cursor(QueryCursor) -> ok@ QueryCursor =  query_cursor()    
eval@eval(QH) -> Answers | Error@ QH =  Answers =  Error = {error, module(), Reason} Reason =  file_sorter:reason()    
eval@eval(QH, Options) -> Answers | Error@ QH =  Answers =  Options = [Option] | Option Option = {cache_all,  Error = {error, module(), Reason} Reason =  file_sorter:reason()    
e@e(QH) -> Answers | Error@ QH =  Answers =  Error = {error, module(), Reason} Reason =  file_sorter:reason()    
e@e(QH, Options) -> Answers | Error@ QH =  Options = [Option] | Option Option = {cache_all,  Answers =  Error = {error, module(), Reason} Reason =  file_sorter:reason()    
fold@fold(Function, Acc0, QH) -> Acc1 | Error@ QH =  Function = fun(( Acc0 = Acc1 = AccIn = AccOut = term() Error = {error, module(), Reason} Reason =  file_sorter:reason()    
fold@fold(Function, Acc0, QH, Options) -> Acc1 | Error@ QH =  Function = fun(( Acc0 = Acc1 = AccIn = AccOut = term() Options = [Option] | Option Option = {cache_all,  Error = {error, module(), Reason} Reason =  file_sorter:reason()    
format_error@format_error(Error) -> Chars@ Error = {error, module(), term()} Chars =  io_lib:chars()    
info@info(QH) -> Info@ QH =  Info =  abstract_expr()  | string()   
info@info(QH, Options) -> Info@ QH =  Options = [Option] | Option Option = EvalOption | ReturnOption EvalOption = {cache_all,  ReturnOption = {depth, Depth} Depth = infinity | integer() >= 0 Format = abstract_code | string NElements = infinity | integer() >= 1 Info =  abstract_expr()  | string()   
keysort@keysort(KeyPos, QH1) -> QH2@ KeyPos =  QH1 =  QH2 =  query_handle()    
keysort@keysort(KeyPos, QH1, SortOptions) -> QH2@ KeyPos =  SortOptions =  QH1 =  QH2 =  query_handle()    
next_answers@next_answers(QueryCursor) -> Answers | Error@ QueryCursor =  Answers =  Error = {error, module(), Reason} Reason =  file_sorter:reason()    
next_answers@next_answers(QueryCursor, NumberOfAnswers) -> Answers | Error@ QueryCursor =  Answers =  NumberOfAnswers = all_remaining | integer() >= 1 Error = {error, module(), Reason} Reason =  file_sorter:reason()    
q@q(QLC) -> QH@ QLC =  QH =  query_handle()    
q@q(QLC, Options) -> QH@ QH =  Options = [Option] | Option Option = {max_lookup, MaxLookup} MaxLookup = integer() >= 0 | infinity Join = any | lookup | merge | nested_loop Lookup = boolean() | any QLC =  query_list_comprehension()    
sort@sort(QH1) -> QH2@ QH1 =  QH2 =  query_handle()    
sort@sort(QH1, SortOptions) -> QH2@ SortOptions =  QH1 =  QH2 =  query_handle()    
string_to_handle@string_to_handle(QueryString) -> QH | Error@ QueryString = string() QH =  Error = {error, module(), Reason} Reason =  erl_parse:error_info()  |  erl_scan:error_info()    
string_to_handle@string_to_handle(QueryString, Options) -> QH | Error@ QueryString = string() Options = [Option] | Option Option = {max_lookup, MaxLookup} MaxLookup = integer() >= 0 | infinity Join = any | lookup | merge | nested_loop Lookup = boolean() | any QH =  Error = {error, module(), Reason} Reason =  erl_parse:error_info()  |  erl_scan:error_info()    
string_to_handle@string_to_handle(QueryString, Options, Bindings) -> QH | Error@ QueryString = string() Options = [Option] | Option Option = {max_lookup, MaxLookup} MaxLookup = integer() >= 0 | infinity Join = any | lookup | merge | nested_loop Lookup = boolean() | any Bindings =  QH =  Error = {error, module(), Reason} Reason =  erl_parse:error_info()  |  erl_scan:error_info()    
table@table(TraverseFun, Options) -> QH@ TraverseFun = TraverseFun0 | TraverseFun1 TraverseFun0 = fun(() -> TraverseResult) TraverseFun1 = fun(( TraverseResult = Objects | term() Objects = [] | [term() | ObjectList] ObjectList = TraverseFun0 | Objects Options = [Option] | Option Option = {format_fun, FormatFun} FormatFun = undefined | fun((SelectedObjects) -> FormatedTable) SelectedObjects = all NElements = infinity | integer() >= 1 DepthFun = fun((term()) -> term()) FormatedTable = {Mod, Fun, Args} |  InfoFun = undefined | fun((InfoTag) -> InfoValue) InfoTag = indices | is_unique_objects | keypos | num_of_objects InfoValue = undefined | term() LookupFun = undefined | fun((Position, Keys) -> LookupResult) LookupResult = [term()] | term() ParentFun = undefined | fun(() -> ParentFunValue) PostFun = undefined | fun(() -> term()) PreFun = undefined | fun((PreArgs) -> term()) PreArgs = [PreArg] PreArg = {parent_value, ParentFunValue} | {stop_fun, StopFun} ParentFunValue = undefined | term() StopFun = undefined | fun(() -> term()) KeyComparison = '=:=' | '==' Position = integer() >= 1 Keys = [term()] Mod = Fun = atom() Args = [term()] QH =  query_handle()    
