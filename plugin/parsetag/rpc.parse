call@call(Node, Module, Function, Args) -> Res | {badrpc, Reason}@ Node = node() Module = module() Function = atom() Args = [term()] Res = Reason = term()   
call@call(Node, Module, Function, Args, Timeout) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Res | {badrpc, Reason}@ Node = node() Module = module() Function = atom() Args = [term()] Res = Reason = term() Timeout = timeout()   
block_call@block_call(Node, Module, Function, Args) -> Res | {badrpc, Reason}@ Node = node() Module = module() Function = atom() Args = [term()] Res = Reason = term()   
block_call@block_call(Node, Module, Function, Args, Timeout) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Res | {badrpc, Reason}@ Node = node() Module = module() Function = atom() Args = [term()] Res = Reason = term() Timeout = timeout()   
async_call@async_call(Node, Module, Function, Args) -> Key@ Node = node() Module = module() Function = atom() Args = [term()] Key =  key()    
yield@yield(Key) -> Res | {badrpc, Reason}@ Key =  Res = Reason = term()   
nb_yield@nb_yield(Key) -> {value, Val} | timeout@ Key =  Val = (Res :: term()) | {badrpc, Reason :: term()}   
nb_yield@nb_yield(Key, Timeout) -> {value, Val} | timeout@ Key =  Timeout = timeout() Val = (Res :: term()) | {badrpc, Reason :: term()}   
multicall@multicall(Module, Function, Args) -> {ResL, BadNodes}@ Module = module() Function = atom() Args = ResL = [term()] BadNodes = [node()]   
multicall@multicall(Nodes, Module, Function, Args) -> {ResL, BadNodes}</h3><h3>multicall(Module, Function, Args, Timeout) -> {ResL, BadNodes}@ Nodes = [node()] Module = module() Function = atom() Args = ResL = [term()] BadNodes = [node()] Args = [term()] Timeout = timeout() ResL = [term()]   
multicall@multicall(Nodes, Module, Function, Args, Timeout) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ResL, BadNodes}@ Nodes = [node()] Module = module() Function = atom() Args = [term()] Timeout = timeout() ResL = [term()] BadNodes = [node()]   
cast@cast(Node, Module, Function, Args) -> true@ Node = node() Module = module() Function = atom() Args = [term()]   
eval_everywhere@eval_everywhere(Module, Function, Args) -> abcast@ Module = module() Function = atom() Args = [term()]   
eval_everywhere@eval_everywhere(Nodes, Module, Function, Args) -> abcast@ Nodes = [node()] Module = module() Function = atom() Args = [term()]   
abcast@abcast(Name, Msg) -> abcast@ Name = atom() Msg = term()   
abcast@abcast(Nodes, Name, Msg) -> abcast@ Nodes = [node()] Name = atom() Msg = term()   
sbcast@sbcast(Name, Msg) -> {GoodNodes, BadNodes}@ Name = atom() Msg = term() GoodNodes = BadNodes = [node()]   
sbcast@sbcast(Nodes, Name, Msg) -> {GoodNodes, BadNodes}@ Name = atom() Msg = term() Nodes = GoodNodes = BadNodes = [node()]   
server_call@server_call(Node, Name, ReplyWrapper, Msg) -><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reply | {error, Reason}@ Node = node() Name = atom() ReplyWrapper = Msg = Reply = term() Reason = nodedown   
multi_server_call@multi_server_call(Name, Msg) -> {Replies, BadNodes}@ Name = atom() Msg = term() Replies = [Reply :: term()] BadNodes = [node()]   
multi_server_call@multi_server_call(Nodes, Name, Msg) -> {Replies, BadNodes}@ Nodes = [node()] Name = atom() Msg = term() Replies = [Reply :: term()] BadNodes = [node()]   
safe_multi_server_call@safe_multi_server_call(Name, Msg) -> {Replies, BadNodes}@ Name = atom() Msg = term() Replies = [Reply :: term()] BadNodes = [node()]   
safe_multi_server_call@safe_multi_server_call(Nodes, Name, Msg) -> {Replies, BadNodes}@ Nodes = [node()] Name = atom() Msg = term() Replies = [Reply :: term()] BadNodes = [node()]   
parallel_eval@parallel_eval(FuncCalls) -> ResL@ FuncCalls = [{Module, Function, Args}] Module = module() Function = atom() Args = ResL = [term()]   
pmap@pmap(FuncSpec, ExtraArgs, List1) -> List2@ FuncSpec = {Module, Function} Module = module() Function = atom() ExtraArgs = [term()] List1 = [Elem :: term()] List2 = [term()]   
pinfo@pinfo(Pid) -> [{Item, Info}] | undefined@ Pid = pid() Item = atom() Info = term()   
pinfo@pinfo(Pid, Item) -> {Item, Info} | undefined | []@ Pid = pid() Item = atom() Info = term()   
